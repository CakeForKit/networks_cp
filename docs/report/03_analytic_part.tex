\chapter{Аналитическая часть}

В данном разделе рассматривается протокол HTTP/1.1 и архитектура prefork + poll().

\section{Анализ протокола HTTP для статического контента}


\subsection*{HTTP/1.1}

HTTP (HyperText Transfer Protocol) — протокол прикладного уровня модели OSI, предназначенный для передачи гипертекстовых документов. Версия HTTP/1.1~\cite{rfc2616} поддерживает постоянные соединения (keep-alive), сокращая накладные расходы на установку TCP-соединения для каждого запроса.

\subsection*{Структура HTTP-сообщений}
Основной единицей взаимодействия в HTTP является сообщение. Запрос клиента состоит из:
\begin{itemize}[nosep]
	\item Стартовой строки — содержит метод, URI и версию протокола.
	\item Заголовков (headers) — параметры запроса в формате «ключ: значение».
	\item Тела запроса (body) — опциональные данные (отсутствует для GET и HEAD).
\end{itemize}

Ответ сервера состоит из:
\begin{itemize}[nosep]
	\item Строки статуса — включает версию протокола, код и описание состояния.
	\item Заголовков ответа — метаинформация о содержимом и сервере.
	\item Тела ответа — передаваемые данные (только для метода GET).
\end{itemize}

\subsection*{MIME-типы контента}
Для корректной интерпретации данных клиентом используется система MIME-типов (Multipurpose Internet Mail Extensions), определяющая формат содержимого. Тип указывается в заголовке Content-Type ответа и формируется на основе расширения файла, например \texttt{text/html}, \texttt{text/css}, \texttt{image/jpeg} и т. д.

\subsection*{Поддерживаемые методы запросов}
Разрабатываемый сервер статического содержимого обрабатывает запросы:
\begin{itemize}
	\item GET — возвращает содержимое ресурса с телом ответа.
	\item HEAD — возвращает только заголовки ответа без тела.
	\item Прочие методы (POST, PUT, DELETE) отклоняются с кодом состояния 405 Method Not Allowed.
\end{itemize}


\subsection*{Коды состояния HTTP}

Код состояния является трехзначным числом, информирующим клиента о результате обработки его запроса. Для корректной работы статического сервера необходимо реализовать обработку следующих статусов:
\begin{itemize}
	\item 200 OK — запрос успешно выполнен; целевой ресурс передан в теле ответа.
	\item 403 Forbidden — сервер отказывается выполнить запрос из-за отсутствия прав доступа к целевому ресурсу;
	\item 404 Not Found — целевой ресурс не существует по указанному URI;
	\item 405 Method Not Allowed — метод запроса не поддерживается для целевого ресурса.
\end{itemize}


\section{Анализ архитектуры prefork + poll()}

\subsection*{Модель prefork}

Prefork (предварительное порождение процессов) — это архитектурный подход к созданию параллельных серверов, при котором основной (родительский, master) процесс заранее создает фиксированный пул дочерних процессов (worker), ожидающих входящие соединения. Родительский процесс обычно отвечает за мониторинг состояния воркеров и их перезапуск в случае аварийного завершения.

Принцип работы модели prefork:
\begin{enumerate}
	\item Сервер запускается и создает слушающий сокет.
	\item Master-процесс порождает заданное количество идентичных worker-процессов с помощью системного вызова \texttt{fork()}~\cite{fork}.
	\item Все worker-процессы наследуют слушающий сокет и одновременно вызывают \texttt{accept()}~\cite{accept} для ожидания нового соединения. Благодаря механизму ядра, только один процесс получит входящее соединение.
	\item Получивший соединение worker обрабатывает его независимо от других.
\end{enumerate}

\subsection*{Модель мультиплексирования с использованием poll()}

Мультиплексирование ввода-вывода — это техника, позволяющая одному процессу (или потоку) отслеживать состояние нескольких файловых дескрипторов (например, сетевых сокетов) одновременно, не блокируя выполнение на ожидании данных от каждого из них по отдельности.

Системный вызов \texttt{poll()}~\cite{poll} предоставляет механизм для синхронного ожидания событий на множестве дескрипторов.

Принцип работы системного вызова poll():
\begin{enumerate}
	\item Программа создает массив структур типа \texttt{struct pollfd}. Для каждого отслеживаемого файлового дескриптора в структуре указывается: сам дескриптор (\texttt{fd}), интересующие события (\texttt{events}) и произошедшие события (\texttt{revents}).
	\item Типичные отслеживаемые события:
	\begin{itemize}
		\item \texttt{POLLIN} — данные доступны для чтения (поступление нового HTTP-запроса).
		\item \texttt{POLLOUT} — дескриптор готов для записи (можно отправлять HTTP-ответ).
		\item \texttt{POLLERR}, \texttt{POLLHUP} — произошла ошибка или соединение закрыто.
	\end{itemize}
	\item Программа передает массив структур и таймаут в системный вызов \texttt{poll()}. Вызов блокирует выполнение процесса до тех пор, пока не произойдет хотя бы одно из запрошенных событий на одном из дескрипторов, либо не истечет таймаут.
	\item Когда \texttt{poll()} возвращает управление, программа сканирует массив, проверяя поле \texttt{revents} в каждой структуре, чтобы определить, на каких дескрипторах произошли события.
	\item Для каждого «готового» дескриптора выполняется соответствующая операция (чтение запроса, отправка ответа, закрытие соединения).
\end{enumerate}


\subsection*{prefork + poll()}
Архитектура prefork + poll() представляет собой гибридный подход, сочетающий преимущества многопроцессной модели и механизма мультиплексирования ввода-вывода.

При данной архитектуре каждый worker-процесс способен обслуживать несколько одновременных соединений в рамках одного потока выполнения, используя системный вызов poll() для отслеживания состояния множества файловых дескрипторов.



\section*{Вывод}
В данном разделе были представлено описание протокола HTTP/1.1 и архитектуры prefork + poll().
